package preview

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	argocmd "github.com/argoproj/argo-cd/v3/cmd/argocd/commands"
	argoappv1 "github.com/argoproj/argo-cd/v3/pkg/apis/application/v1alpha1"
	repoapiclient "github.com/argoproj/argo-cd/v3/reposerver/apiclient"
	"github.com/argoproj/argo-cd/v3/reposerver/metrics"
	"github.com/argoproj/argo-cd/v3/reposerver/repository"
	"github.com/argoproj/argo-cd/v3/util/argo"
	"github.com/argoproj/argo-cd/v3/util/git"
	"github.com/argoproj/pkg/errors"
	log "github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/api/resource"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

const (
	applicationAPIVersion = "argoproj.io/v1alpha1"
	applicationKind       = "Application"
)

// shouldMatch returns true if the value is non-empty
func shouldMatch(v string) bool {
	return len(v) > 0
}

// getCacheDir returns the cache directory for repositories and helm charts.
// Uses XDG_CACHE_HOME if set, otherwise defaults to ~/.cache on Linux/macOS.
// Can be overridden with ARGOCD_OFFLINE_CLI_CACHE_DIR environment variable.
func getCacheDir() string {
	// Check for override via environment variable
	if dir := os.Getenv("ARGOCD_OFFLINE_CLI_CACHE_DIR"); dir != "" {
		return dir
	}

	// Use XDG_CACHE_HOME or default
	cacheHome := os.Getenv("XDG_CACHE_HOME")
	if cacheHome == "" {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			// Fallback to temp dir if we can't get home dir
			log.Warnf("Unable to determine home directory, using temp dir: %v", err)
			return filepath.Join(os.TempDir(), "_argocd-offline-cli")
		}
		cacheHome = filepath.Join(homeDir, ".cache")
	}

	return filepath.Join(cacheHome, "argocd-offline-cli")
}

// generateAndOutputManifests generates manifests for Applications and outputs them
func generateAndOutputManifests(apps []argoappv1.Application, appName string, resKind string, output string) {
	max, err := resource.ParseQuantity("100G")
	errors.CheckError(err)
	maxValue := max.ToDec().Value()
	initConstants := repository.RepoServerInitConstants{
		HelmManifestMaxExtractedSize:      maxValue,
		HelmRegistryMaxIndexSize:          maxValue,
		MaxCombinedDirectoryManifestsSize: max,
		StreamedManifestMaxExtractedSize:  maxValue,
		StreamedManifestMaxTarSize:        maxValue,
	}

	repoService := repository.NewService(
		metrics.NewMetricsServer(),
		NewNoopCache(),
		initConstants,
		argo.NewResourceTracking(),
		git.NoopCredsStore{},
		getCacheDir(),
	)
	if err := repoService.Init(); err != nil {
		log.Fatal("failed to initialize the repo service: ", err)
	}

	for _, app := range apps {
		if !shouldMatch(appName) || appName == app.Name {
			// Normalize source handling using ArgoCD v3 helper methods
			sources := app.Spec.GetSources() // Normalize to array
			if len(sources) == 0 {
				log.Fatalf("Application '%s' has no source configured (.spec.source or .spec.sources)", app.Name)
			}

			var manifests []string
			var err error

			if app.Spec.HasMultipleSources() {
				// Multi-source path
				manifests, err = generateMultiSourceManifests(repoService, app)
				if err != nil {
					log.Fatalf("Failed to generate manifests for multi-source app '%s': %v", app.Name, err)
				}
			} else {
				// Single-source path (existing logic)
				manifests, err = generateSingleSourceManifest(repoService, app)
				if err != nil {
					log.Fatalf("Failed to generate manifests for app '%s': %v", app.Name, err)
				}
			}

			// Construct response from manifests generated by routing logic
			response := &repoapiclient.ManifestResponse{
				Manifests: manifests,
			}

			resources := map[string][]unstructured.Unstructured{}
			for _, manifest := range response.Manifests {
				resource := unstructured.Unstructured{}
				err = json.Unmarshal([]byte(manifest), &resource)
				errors.CheckError(err)

				kind := strings.ToLower(resource.GetKind())
				if !shouldMatch(resKind) || resKind == kind {
					if _, ok := resources[kind]; !ok {
						resources[kind] = make([]unstructured.Unstructured, 0)
					}
					resources[kind] = append(resources[kind], resource)
				}
			}
			kinds := make([]string, 0)
			for kind := range resources {
				kinds = append(kinds, kind)
			}
			sort.Strings(kinds)
			switch output {
			case "name":
				printNewline := true
				for _, kind := range kinds {
					if printNewline {
						printNewline = false
					} else {
						fmt.Println()
					}
					fmt.Println("NAME")
					for _, resource := range resources[kind] {
						fmt.Printf("%s/%s\n", kind, resource.GetName())
					}
				}
			case "json", "yaml":
				for _, kind := range kinds {
					argocmd.PrintResourceList(resources[kind], output, false)
				}

			default:
				errors.CheckError(fmt.Errorf("unknown output format: %s", output))
			}
		}
	}
}

// generateSingleSourceManifest handles manifest generation for traditional single-source applications
func generateSingleSourceManifest(repoService *repository.Service, app argoappv1.Application) ([]string, error) {
	if app.Spec.Source == nil || app.Spec.Source.RepoURL == "" {
		return nil, fmt.Errorf("application has no valid source configuration")
	}

	response, err := repoService.GenerateManifest(context.Background(), &repoapiclient.ManifestRequest{
		ApplicationSource: app.Spec.Source,
		AppName:           app.Name,
		Namespace:         app.Spec.Destination.Namespace,
		NoCache:           true,
		Repo: &argoappv1.Repository{
			Repo:     app.Spec.Source.RepoURL,
			Username: FindRepoUsername(app.Spec.Source.RepoURL),
			Password: FindRepoPassword(app.Spec.Source.RepoURL),
		},
		ProjectName: "applications",
	})

	if err != nil {
		return nil, fmt.Errorf("failed to generate manifests: %w", err)
	}

	return response.Manifests, nil
}

// generateMultiSourceManifests handles manifest generation for multi-source applications
// Constraint: all Git repository sources must use the same repository URL
// Helm chart sources (with Chart field set) are allowed to use different repositories
func generateMultiSourceManifests(repoService *repository.Service, app argoappv1.Application) ([]string, error) {
	sources := app.Spec.GetSources()
	if len(sources) == 0 {
		return nil, fmt.Errorf("no sources found in multi-source application")
	}

	// Validate same-repository constraint for Git sources
	// Helm charts (sources with Chart field set) are allowed to have different repos
	var baseGitRepoURL string
	var firstGitSourceIndex int = -1

	for i, source := range sources {
		// Validate that each source has a repoURL
		if source.RepoURL == "" {
			return nil, fmt.Errorf("source at index %d has empty repoURL", i)
		}

		// Skip Helm chart sources - they're allowed to be from different repos
		if source.Chart != "" {
			continue
		}

		// For Git sources, ensure they all use the same repo
		if baseGitRepoURL == "" {
			baseGitRepoURL = source.RepoURL
			firstGitSourceIndex = i
		} else if source.RepoURL != baseGitRepoURL {
			return nil, fmt.Errorf("all Git repository sources must use the same repository. "+
				"Source at index %d uses '%s' but source at index %d (first Git source) uses '%s'",
				i, source.RepoURL, firstGitSourceIndex, baseGitRepoURL)
		}
	}

	// Note: All-Helm applications (where baseGitRepoURL stays empty) are valid.
	// They can use different Helm chart repositories, which is a common pattern
	// for deploying applications from multiple Helm registries.

	// Build reference sources map for cross-source references
	refSources := buildRefSources(sources)

	// Generate manifests for each source
	var allManifests []string
	for i, source := range sources {
		sourceCopy := source // Important: create a copy for the pointer

		// Repository credentials are resolved per-source using the source's repoURL.
		// This allows mixed scenarios:
		// - Multiple Git sources from the same repository
		// - External Helm charts from different registries with their own credentials
		// - Git sources with values + Helm charts with different authentication
		// FindRepoUsername/FindRepoPassword is called for each source's repoURL independently.
		response, err := repoService.GenerateManifest(context.Background(), &repoapiclient.ManifestRequest{
			ApplicationSource:  &sourceCopy,
			AppName:            app.Name,
			Namespace:          app.Spec.Destination.Namespace,
			NoCache:            true,
			HasMultipleSources: true,
			RefSources:         refSources,
			Repo: &argoappv1.Repository{
				Repo:     source.RepoURL,
				Username: FindRepoUsername(source.RepoURL),
				Password: FindRepoPassword(source.RepoURL),
			},
			ProjectName: "applications",
		})

		if err != nil {
			return nil, fmt.Errorf("failed to generate manifests for source %d: %w", i, err)
		}

		allManifests = append(allManifests, response.Manifests...)
	}

	return allManifests, nil
}

// buildRefSources creates a map of named source references for cross-source value file resolution
// The map keys use the "$ref" format (e.g., "$values") to match ArgoCD's cross-source reference syntax
//
// Note: RefTarget intentionally does NOT include the Path field from ApplicationSource.
// This is by design in ArgoCD v3's API. The Path is used during manifest generation, but
// the RefTarget only needs to identify the repository, revision, and chart (if Helm).
// The actual path resolution happens during the GenerateManifest call for each source.
func buildRefSources(sources []argoappv1.ApplicationSource) map[string]*argoappv1.RefTarget {
	refSources := make(map[string]*argoappv1.RefTarget)

	for _, source := range sources {
		if source.Ref != "" {
			// Add "$" prefix to match ArgoCD's reference syntax
			refKey := "$" + source.Ref
			refSources[refKey] = &argoappv1.RefTarget{
				TargetRevision: source.TargetRevision,
				Repo: argoappv1.Repository{
					Repo: source.RepoURL,
				},
				Chart: source.Chart,
			}
		}
	}

	return refSources
}
