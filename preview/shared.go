package preview

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	argocmd "github.com/argoproj/argo-cd/v3/cmd/argocd/commands"
	argoappv1 "github.com/argoproj/argo-cd/v3/pkg/apis/application/v1alpha1"
	repoapiclient "github.com/argoproj/argo-cd/v3/reposerver/apiclient"
	"github.com/argoproj/argo-cd/v3/reposerver/metrics"
	"github.com/argoproj/argo-cd/v3/reposerver/repository"
	"github.com/argoproj/argo-cd/v3/util/argo"
	"github.com/argoproj/argo-cd/v3/util/git"
	"github.com/argoproj/pkg/errors"
	log "github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/api/resource"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

const (
	applicationAPIVersion = "argoproj.io/v1alpha1"
	applicationKind       = "Application"
)

// normalizeGitURL converts various Git URL formats to a comparable form
// This allows comparison of SSH and HTTPS URLs for the same repository
func normalizeGitURL(url string) string {
	// Convert SSH to HTTPS format for comparison
	if strings.HasPrefix(url, "git@") {
		// git@github.com:owner/repo.git -> github.com/owner/repo
		url = strings.TrimPrefix(url, "git@")
		url = strings.Replace(url, ":", "/", 1)
	}

	// Remove protocol
	url = strings.TrimPrefix(url, "https://")
	url = strings.TrimPrefix(url, "http://")

	// Remove .git suffix
	url = strings.TrimSuffix(url, ".git")

	return strings.ToLower(url)
}

// isLocalRepository checks if the given repoURL matches the current git repository
// Returns: (isLocal bool, localPath string, error)
//
// Return value combinations:
// - (true, "/path/to/repo", nil): repoURL matches current repo, use local path
// - (false, "", nil): repoURL does not match, or not in a git repo, or no origin configured
// - (false, "", error): matched but failed to get repo root (unexpected error)
func isLocalRepository(repoURL string) (bool, string, error) {
	// Get current repository's remote URL
	cmd := exec.Command("git", "config", "--get", "remote.origin.url")
	output, err := cmd.Output()
	if err != nil {
		// Not in a git repo or no origin - this is not an error condition
		return false, "", nil
	}

	currentRepo := strings.TrimSpace(string(output))

	// Normalize both URLs for comparison
	normalizedCurrent := normalizeGitURL(currentRepo)
	normalizedTarget := normalizeGitURL(repoURL)

	if normalizedCurrent == normalizedTarget {
		// Get repository root directory
		cmd = exec.Command("git", "rev-parse", "--show-toplevel")
		rootDir, err := cmd.Output()
		if err != nil {
			return false, "", err
		}
		return true, strings.TrimSpace(string(rootDir)), nil
	}

	return false, "", nil
}

// shouldMatch returns true if the value is non-empty
func shouldMatch(v string) bool {
	return len(v) > 0
}

// getCacheDir returns the cache directory for repositories and helm charts.
// Uses the system temp directory to avoid cross-device link errors when
// ArgoCD needs to move files between directories.
func getCacheDir() string {
	return filepath.Join(os.TempDir(), "_argocd-offline-cli")
}

// generateAndOutputManifests generates manifests for Applications and outputs them
func generateAndOutputManifests(apps []argoappv1.Application, appName string, resKind string, output string) {
	max, err := resource.ParseQuantity("100G")
	errors.CheckError(err)
	maxValue := max.ToDec().Value()
	initConstants := repository.RepoServerInitConstants{
		HelmManifestMaxExtractedSize:      maxValue,
		HelmRegistryMaxIndexSize:          maxValue,
		MaxCombinedDirectoryManifestsSize: max,
		StreamedManifestMaxExtractedSize:  maxValue,
		StreamedManifestMaxTarSize:        maxValue,
	}

	repoService := repository.NewService(
		metrics.NewMetricsServer(),
		NewNoopCache(),
		initConstants,
		argo.NewResourceTracking(),
		git.NoopCredsStore{},
		getCacheDir(),
	)
	if err := repoService.Init(); err != nil {
		log.Fatal("failed to initialize the repo service: ", err)
	}

	for _, app := range apps {
		if !shouldMatch(appName) || appName == app.Name {
			// Normalize source handling using ArgoCD v3 helper methods
			sources := app.Spec.GetSources() // Normalize to array
			if len(sources) == 0 {
				log.Fatalf("Application '%s' has no source configured (.spec.source or .spec.sources)", app.Name)
			}

			var manifests []string
			var err error

			if app.Spec.HasMultipleSources() {
				// Multi-source path
				manifests, err = generateMultiSourceManifests(repoService, app)
				if err != nil {
					log.Fatalf("Failed to generate manifests for multi-source app '%s': %v", app.Name, err)
				}
			} else {
				// Single-source path (existing logic)
				manifests, err = generateSingleSourceManifest(repoService, app)
				if err != nil {
					log.Fatalf("Failed to generate manifests for app '%s': %v", app.Name, err)
				}
			}

			// Construct response from manifests generated by routing logic
			response := &repoapiclient.ManifestResponse{
				Manifests: manifests,
			}

			resources := map[string][]unstructured.Unstructured{}
			for _, manifest := range response.Manifests {
				resource := unstructured.Unstructured{}
				err = json.Unmarshal([]byte(manifest), &resource)
				errors.CheckError(err)

				kind := strings.ToLower(resource.GetKind())
				if !shouldMatch(resKind) || resKind == kind {
					if _, ok := resources[kind]; !ok {
						resources[kind] = make([]unstructured.Unstructured, 0)
					}
					resources[kind] = append(resources[kind], resource)
				}
			}
			kinds := make([]string, 0)
			for kind := range resources {
				kinds = append(kinds, kind)
			}
			sort.Strings(kinds)
			switch output {
			case "name":
				printNewline := true
				for _, kind := range kinds {
					if printNewline {
						printNewline = false
					} else {
						fmt.Println()
					}
					fmt.Println("NAME")
					for _, resource := range resources[kind] {
						fmt.Printf("%s/%s\n", kind, resource.GetName())
					}
				}
			case "json", "yaml":
				for _, kind := range kinds {
					argocmd.PrintResourceList(resources[kind], output, false)
				}

			default:
				errors.CheckError(fmt.Errorf("unknown output format: %s", output))
			}
		}
	}
}

// generateSingleSourceManifest handles manifest generation for traditional single-source applications
func generateSingleSourceManifest(repoService *repository.Service, app argoappv1.Application) ([]string, error) {
	if app.Spec.Source == nil || app.Spec.Source.RepoURL == "" {
		return nil, fmt.Errorf("application has no valid source configuration")
	}

	// Check if this is a local repository
	var repoOverride *argoappv1.Repository
	isLocal, localPath, _ := isLocalRepository(app.Spec.Source.RepoURL)
	if isLocal {
		log.Infof("Detected local repository for %s, using path: %s", app.Name, localPath)
		// localPath is from git rev-parse --show-toplevel and is therefore trusted
		repoOverride = &argoappv1.Repository{
			Repo: "file://" + filepath.ToSlash(localPath),
			Type: "git",
		}
	} else {
		// Use existing credential resolution
		log.Debugf("Using remote repository for %s: %s", app.Name, app.Spec.Source.RepoURL)
		repoOverride = &argoappv1.Repository{
			Repo:     app.Spec.Source.RepoURL,
			Username: FindRepoUsername(app.Spec.Source.RepoURL),
			Password: FindRepoPassword(app.Spec.Source.RepoURL),
		}
	}

	response, err := repoService.GenerateManifest(context.Background(), &repoapiclient.ManifestRequest{
		ApplicationSource: app.Spec.Source,
		AppName:           app.Name,
		Namespace:         app.Spec.Destination.Namespace,
		NoCache:           true,
		Repo:              repoOverride,
		ProjectName:       "applications",
	})

	if err != nil {
		return nil, fmt.Errorf("failed to generate manifests: %w", err)
	}

	return response.Manifests, nil
}

// generateMultiSourceManifests handles manifest generation for multi-source applications
// Constraint: all Git repository sources must use the same repository URL
// Helm chart sources (with Chart field set) are allowed to use different repositories
func generateMultiSourceManifests(repoService *repository.Service, app argoappv1.Application) ([]string, error) {
	sources := app.Spec.GetSources()
	if len(sources) == 0 {
		return nil, fmt.Errorf("no sources found in multi-source application")
	}

	// Validate same-repository constraint for Git sources
	// Helm charts (sources with Chart field set) are allowed to have different repos
	var baseGitRepoURL string
	var firstGitSourceIndex int = -1

	for i, source := range sources {
		// Validate that each source has a repoURL
		if source.RepoURL == "" {
			return nil, fmt.Errorf("source at index %d has empty repoURL", i)
		}

		// Skip Helm chart sources - they're allowed to be from different repos
		if source.Chart != "" {
			continue
		}

		// For Git sources, ensure they all use the same repo
		if baseGitRepoURL == "" {
			baseGitRepoURL = source.RepoURL
			firstGitSourceIndex = i
		} else if source.RepoURL != baseGitRepoURL {
			return nil, fmt.Errorf("all Git repository sources must use the same repository. "+
				"Source at index %d uses '%s' but source at index %d (first Git source) uses '%s'",
				i, source.RepoURL, firstGitSourceIndex, baseGitRepoURL)
		}
	}

	// Note: All-Helm applications (where baseGitRepoURL stays empty) are valid.
	// They can use different Helm chart repositories, which is a common pattern
	// for deploying applications from multiple Helm registries.

	// Build reference sources map for cross-source references
	refSources := buildRefSources(sources)

	// Generate manifests for each source
	var allManifests []string
	for i, source := range sources {
		sourceCopy := source // Important: create a copy for the pointer

		// Check if this source is a local repository
		var repoOverride *argoappv1.Repository
		isLocal, localPath, _ := isLocalRepository(source.RepoURL)
		if isLocal && source.Chart == "" {
			// Only use local path for Git sources, not Helm charts
			log.Infof("Detected local repository for source %d in %s, using path: %s", i, app.Name, localPath)
			// localPath is from git rev-parse --show-toplevel and is therefore trusted
			repoOverride = &argoappv1.Repository{
				Repo: "file://" + filepath.ToSlash(localPath),
				Type: "git",
			}
		} else {
			// Repository credentials are resolved per-source using the source's repoURL.
			// This allows mixed scenarios:
			// - Multiple Git sources from the same repository
			// - External Helm charts from different registries with their own credentials
			// - Git sources with values + Helm charts with different authentication
			// FindRepoUsername/FindRepoPassword is called for each source's repoURL independently.
			log.Debugf("Using remote repository for source %d in %s: %s", i, app.Name, source.RepoURL)
			repoOverride = &argoappv1.Repository{
				Repo:     source.RepoURL,
				Username: FindRepoUsername(source.RepoURL),
				Password: FindRepoPassword(source.RepoURL),
			}
		}

		response, err := repoService.GenerateManifest(context.Background(), &repoapiclient.ManifestRequest{
			ApplicationSource:  &sourceCopy,
			AppName:            app.Name,
			Namespace:          app.Spec.Destination.Namespace,
			NoCache:            true,
			HasMultipleSources: true,
			RefSources:         refSources,
			Repo:               repoOverride,
			ProjectName:        "applications",
		})

		if err != nil {
			return nil, fmt.Errorf("failed to generate manifests for source %d: %w", i, err)
		}

		allManifests = append(allManifests, response.Manifests...)
	}

	return allManifests, nil
}

// buildRefSources creates a map of named source references for cross-source value file resolution
// The map keys use the "$ref" format (e.g., "$values") to match ArgoCD's cross-source reference syntax
//
// Note: RefTarget intentionally does NOT include the Path field from ApplicationSource.
// This is by design in ArgoCD v3's API. The Path is used during manifest generation, but
// the RefTarget only needs to identify the repository, revision, and chart (if Helm).
// The actual path resolution happens during the GenerateManifest call for each source.
func buildRefSources(sources []argoappv1.ApplicationSource) map[string]*argoappv1.RefTarget {
	refSources := make(map[string]*argoappv1.RefTarget)

	for _, source := range sources {
		if source.Ref != "" {
			// Add "$" prefix to match ArgoCD's reference syntax
			refKey := "$" + source.Ref
			refSources[refKey] = &argoappv1.RefTarget{
				TargetRevision: source.TargetRevision,
				Repo: argoappv1.Repository{
					Repo: source.RepoURL,
				},
				Chart: source.Chart,
			}
		}
	}

	return refSources
}
